// This File was auto generated by BungoKitGen
//
// File: ContentItemPublicContract.swift

import AnyCodable
import Foundation
public extension Content {
    struct ContentItemPublicContract: Codable {
        public var allowComments: Bool?
        public var author: User.GeneralUser?
        public var autoEnglishPropertyFallback: Bool?
        public var cType: String?
        public var cmsPath: String?
        public var commentSummary: Content.CommentSummary?
        public var contentId: Int64?
        public var creationDate: Date?
        public var hasAgeGate: Bool?
        public var minimumAge: Int32?
        public var modifyDate: Date?
        /// Firehose content is really a collection of metadata and "properties", which are the potentially-but-not-strictly localizable data that comprises the meat of whatever content is being shown.
        /// As Cole Porter would have crooned, "Anything Goes" with Firehose properties. They are most often strings, but they can theoretically be anything. They are JSON encoded, and could be JSON structures, simple strings, numbers etc... The Content Type of the item (cType) will describe the properties, and thus how they ought to be deserialized.
        public var properties: [String: AnyCodable]?
        public var ratingImagePath: String?
        public var representations: [Content.ContentRepresentation]?
        /// NOTE: Tags will always be lower case.
        public var tags: [String]?

        public enum CodingKeys: String, CodingKey {
            case allowComments
            case author
            case autoEnglishPropertyFallback
            case cType
            case cmsPath
            case commentSummary
            case contentId
            case creationDate
            case hasAgeGate
            case minimumAge
            case modifyDate
            case properties
            case ratingImagePath
            case representations
            case tags
        }

        public init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            allowComments = try? container.decode(Bool.self, forKey: CodingKeys.allowComments)
            author = try? container.decode(User.GeneralUser.self, forKey: CodingKeys.author)
            autoEnglishPropertyFallback = try? container.decode(Bool.self, forKey: CodingKeys.autoEnglishPropertyFallback)
            cType = try? container.decode(String.self, forKey: CodingKeys.cType)
            cmsPath = try? container.decode(String.self, forKey: CodingKeys.cmsPath)
            commentSummary = try? container.decode(Content.CommentSummary.self, forKey: CodingKeys.commentSummary)
            let contentId = try? container.decode(String.self, forKey: CodingKeys.contentId)
            if let contentId, let contentIdInt = Int64(contentId) {
                self.contentId = contentIdInt
            } else {
                self.contentId = nil
            }
            creationDate = try? container.decode(Date.self, forKey: CodingKeys.creationDate)
            hasAgeGate = try? container.decode(Bool.self, forKey: CodingKeys.hasAgeGate)
            minimumAge = try? container.decode(Int32.self, forKey: CodingKeys.minimumAge)
            modifyDate = try? container.decode(Date.self, forKey: CodingKeys.modifyDate)
            properties = try? container.decode([String: AnyCodable].self, forKey: CodingKeys.properties)
            ratingImagePath = try? container.decode(String.self, forKey: CodingKeys.ratingImagePath)
            representations = try? container.decode([Content.ContentRepresentation].self, forKey: CodingKeys.representations)
            tags = try? container.decode([String].self, forKey: CodingKeys.tags)
        }
    }
}
