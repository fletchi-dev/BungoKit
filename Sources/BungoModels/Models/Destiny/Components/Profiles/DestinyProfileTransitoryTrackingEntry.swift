// This File was auto generated by BungoKitGen
//
// File: DestinyProfileTransitoryTrackingEntry.swift

import Foundation

public extension Destiny.Components.Profiles {
    /// This represents a single "thing" being tracked by the player.
    /// This can point to many types of entities, but only a subset of them will actually have a valid hash identifier for whatever it is being pointed to.
    /// It's up to you to interpret what it means when various combinations of these entries have values being tracked.
    struct DestinyProfileTransitoryTrackingEntry: Codable {
        /// OPTIONAL - If this is tracking the status of a DestinyActivityDefinition, this is the identifier for that activity.
        public var activityHash: UInt32?
        /// OPTIONAL - If this is tracking the status of a DestinyInventoryItemDefinition, this is the identifier for that item.
        public var itemHash: UInt32?
        /// OPTIONAL - If this is tracking a DestinyLocationDefinition, this is the identifier for that location.
        public var locationHash: UInt32?
        /// OPTIONAL - If this is tracking the status of a DestinyObjectiveDefinition, this is the identifier for that objective.
        public var objectiveHash: UInt32?
        /// OPTIONAL - If this is tracking the status of a quest, this is the identifier for the DestinyInventoryItemDefinition that containst that questline data.
        public var questlineItemHash: UInt32?
        /// OPTIONAL - I've got to level with you, I don't really know what this is. Is it when you started tracking it? Is it only populated for tracked items that have time limits?
        /// I don't know, but we can get at it - when I get time to actually test what it is, I'll update this. In the meantime, bask in the mysterious data.
        public var trackedDate: Date?

        public enum CodingKeys: String, CodingKey {
            case activityHash
            case itemHash
            case locationHash
            case objectiveHash
            case questlineItemHash
            case trackedDate
        }

        public init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            activityHash = try? container.decode(UInt32.self, forKey: CodingKeys.activityHash)
            itemHash = try? container.decode(UInt32.self, forKey: CodingKeys.itemHash)
            locationHash = try? container.decode(UInt32.self, forKey: CodingKeys.locationHash)
            objectiveHash = try? container.decode(UInt32.self, forKey: CodingKeys.objectiveHash)
            questlineItemHash = try? container.decode(UInt32.self, forKey: CodingKeys.questlineItemHash)
            trackedDate = try? container.decode(Date.self, forKey: CodingKeys.trackedDate)
        }
    }
}
