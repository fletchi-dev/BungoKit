// This File was auto generated by BungoCodeGen and should not be modified.
//
// File: DestinyItemInventoryBlockDefinition.swift

import Foundation

public extension Destiny.Definitions {
    /// If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory.
    struct DestinyItemInventoryBlockDefinition: Codable {
        /// The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this "bucketHash", but too many things refer to it now. Sigh.
        public var bucketTypeHash: UInt32?

        /// The tooltip message to show, if any, when the item expires.
        public var expirationTooltip: String?

        /// If the item expires while playing in an activity, we show a different message.
        public var expiredInActivityMessage: String?

        /// If the item expires in orbit, we show a... more different message. ("Consummate V's, consummate!")
        public var expiredInOrbitMessage: String?

        /// If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer).
        public var isInstanceItem: Bool?

        /// The maximum quantity of this item that can exist in a stack.
        public var maxStackSize: Int32?

        /// A reference to the associated crafting 'recipe' item definition, if this item can be crafted.
        public var recipeItemHash: UInt32?

        /// If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead.
        public var recoveryBucketTypeHash: UInt32?

        /// If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness.
        public var stackUniqueLabel: String?

        public var suppressExpirationWhenObjectivesComplete: Bool?

        /// The enumeration matching the tier type of the item to known values, again for convenience sake.
        public var tierType: Destiny.TierType?

        /// The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier.
        public var tierTypeHash: UInt32?

        /// The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to.
        public var tierTypeName: String?

        public enum CodingKeys: String, CodingKey {
            case bucketTypeHash
            case expirationTooltip
            case expiredInActivityMessage
            case expiredInOrbitMessage
            case isInstanceItem
            case maxStackSize
            case recipeItemHash
            case recoveryBucketTypeHash
            case stackUniqueLabel
            case suppressExpirationWhenObjectivesComplete
            case tierType
            case tierTypeHash
            case tierTypeName
        }

        public init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            bucketTypeHash = try? container.decode(UInt32.self, forKey: CodingKeys.bucketTypeHash)
            expirationTooltip = try? container.decode(String.self, forKey: CodingKeys.expirationTooltip)
            expiredInActivityMessage = try? container.decode(String.self, forKey: CodingKeys.expiredInActivityMessage)
            expiredInOrbitMessage = try? container.decode(String.self, forKey: CodingKeys.expiredInOrbitMessage)
            isInstanceItem = try? container.decode(Bool.self, forKey: CodingKeys.isInstanceItem)
            maxStackSize = try? container.decode(Int32.self, forKey: CodingKeys.maxStackSize)
            recipeItemHash = try? container.decode(UInt32.self, forKey: CodingKeys.recipeItemHash)
            recoveryBucketTypeHash = try? container.decode(UInt32.self, forKey: CodingKeys.recoveryBucketTypeHash)
            stackUniqueLabel = try? container.decode(String.self, forKey: CodingKeys.stackUniqueLabel)
            suppressExpirationWhenObjectivesComplete = try? container.decode(Bool.self, forKey: CodingKeys.suppressExpirationWhenObjectivesComplete)
            tierType = try? container.decode(Destiny.TierType.self, forKey: CodingKeys.tierType)
            tierTypeHash = try? container.decode(UInt32.self, forKey: CodingKeys.tierTypeHash)
            tierTypeName = try? container.decode(String.self, forKey: CodingKeys.tierTypeName)
        }
    }
}
