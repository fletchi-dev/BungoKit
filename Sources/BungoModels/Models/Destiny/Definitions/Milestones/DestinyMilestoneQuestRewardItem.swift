// This File was auto generated by BungoKitGen
//
// File: DestinyMilestoneQuestRewardItem.swift

import Foundation

public extension Destiny.Definitions.Milestones {
    /// A subclass of DestinyItemQuantity, that provides not just the item and its quantity but also information that BNet can - at some point - use internally to provide more robust runtime information about the item's qualities.
    /// If you want it, please ask! We're just out of time to wire it up right now. Or a clever person just may do it with our existing endpoints.
    struct DestinyMilestoneQuestRewardItem: Codable {
        /// Indicates that this item quantity may be conditionally shown or hidden, based on various sources of state. For example: server flags, account state, or character progress.
        public var hasConditionalVisibility: Bool?
        /// The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.
        public var itemHash: UInt32?
        /// If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.
        public var itemInstanceId: Int64?
        /// The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.
        public var quantity: Int32?
        /// The quest reward item *may* be associated with a vendor. If so, this is that vendor. Use this hash to look up the DestinyVendorDefinition.
        public var vendorHash: UInt32?
        /// The quest reward item *may* be associated with a vendor. If so, this is the index of the item being sold, which we can use at runtime to find instanced item information for the reward item.
        public var vendorItemIndex: Int32?

        public enum CodingKeys: String, CodingKey {
            case hasConditionalVisibility
            case itemHash
            case itemInstanceId
            case quantity
            case vendorHash
            case vendorItemIndex
        }

        public init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            hasConditionalVisibility = try? container.decode(Bool.self, forKey: CodingKeys.hasConditionalVisibility)
            itemHash = try? container.decode(UInt32.self, forKey: CodingKeys.itemHash)
            let itemInstanceId = try? container.decode(String.self, forKey: CodingKeys.itemInstanceId)
            if let itemInstanceId, let itemInstanceIdInt = Int64(itemInstanceId) {
                self.itemInstanceId = itemInstanceIdInt
            } else {
                self.itemInstanceId = nil
            }
            quantity = try? container.decode(Int32.self, forKey: CodingKeys.quantity)
            vendorHash = try? container.decode(UInt32.self, forKey: CodingKeys.vendorHash)
            vendorItemIndex = try? container.decode(Int32.self, forKey: CodingKeys.vendorItemIndex)
        }
    }
}
