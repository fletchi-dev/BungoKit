// This File was auto generated by BungoKitGen
//
// File: DestinyLoadoutConstantsDefinition.swift

import Foundation

public extension Destiny.Definitions.Loadouts {
    struct DestinyLoadoutConstantsDefinition: Codable {
        /// This is a color-inverted version of the whiteIconImagePath.
        public var blackIconImagePath: String?
        public var displayProperties: Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition?
        /// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
        /// When entities refer to each other in Destiny content, it is this hash that they are referring to.
        public var hash: UInt32?
        /// The index of the entity as it was found in the investment tables.
        public var index: Int32?
        /// A list of the loadout color hashes in index order, for convenience.
        public var loadoutColorHashes: [UInt32]?
        /// The maximum number of loadouts available to each character. The loadouts component API response can return fewer loadouts than this, as more loadouts are unlocked by reaching higher Guardian Ranks.
        public var loadoutCountPerCharacter: Int32?
        /// A list of the loadout icon hashes in index order, for convenience.
        public var loadoutIconHashes: [UInt32]?
        /// A list of the loadout name hashes in index order, for convenience.
        public var loadoutNameHashes: [UInt32]?
        /// A list of the socket category hashes to be filtered out of loadout item preview displays.
        public var loadoutPreviewFilterOutSocketCategoryHashes: [UInt32]?
        /// A list of the socket type hashes to be filtered out of loadout item preview displays.
        public var loadoutPreviewFilterOutSocketTypeHashes: [UInt32]?
        /// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
        public var redacted: Bool?
        /// This is the same icon as the one in the display properties, offered here as well with a more descriptive name.
        public var whiteIconImagePath: String?

        public enum CodingKeys: String, CodingKey {
            case blackIconImagePath
            case displayProperties
            case hash
            case index
            case loadoutColorHashes
            case loadoutCountPerCharacter
            case loadoutIconHashes
            case loadoutNameHashes
            case loadoutPreviewFilterOutSocketCategoryHashes
            case loadoutPreviewFilterOutSocketTypeHashes
            case redacted
            case whiteIconImagePath
        }

        public init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            blackIconImagePath = try? container.decode(String.self, forKey: CodingKeys.blackIconImagePath)
            displayProperties = try? container.decode(Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition.self, forKey: CodingKeys.displayProperties)
            hash = try? container.decode(UInt32.self, forKey: CodingKeys.hash)
            index = try? container.decode(Int32.self, forKey: CodingKeys.index)
            loadoutColorHashes = try? container.decode([UInt32].self, forKey: CodingKeys.loadoutColorHashes)
            loadoutCountPerCharacter = try? container.decode(Int32.self, forKey: CodingKeys.loadoutCountPerCharacter)
            loadoutIconHashes = try? container.decode([UInt32].self, forKey: CodingKeys.loadoutIconHashes)
            loadoutNameHashes = try? container.decode([UInt32].self, forKey: CodingKeys.loadoutNameHashes)
            loadoutPreviewFilterOutSocketCategoryHashes = try? container.decode([UInt32].self, forKey: CodingKeys.loadoutPreviewFilterOutSocketCategoryHashes)
            loadoutPreviewFilterOutSocketTypeHashes = try? container.decode([UInt32].self, forKey: CodingKeys.loadoutPreviewFilterOutSocketTypeHashes)
            redacted = try? container.decode(Bool.self, forKey: CodingKeys.redacted)
            whiteIconImagePath = try? container.decode(String.self, forKey: CodingKeys.whiteIconImagePath)
        }
    }
}
